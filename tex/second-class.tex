%% For submission and review of your manuscript please change the
%% command to \documentclass[manuscript, screen, review]{acmart}.
%%
%% When submitting camera ready or to TAPS, please change the command
%% to \documentclass[sigconf]{acmart} or whichever template is required
%% for your publication.
%%
%%
\documentclass[sigplan,review,dvipsnames,screen,10pt]{acmart}

\usepackage{listings}
\usepackage{agda}
\usepackage{bbm}

\newcommand{\LamWhatif}{\ensuremath{\lambda^{1/2}_{\hookleftarrow}}}
\newcommand{\LamOurs}{\ensuremath{\lambda^{1/2!}_{\hookleftarrow}}}

\input{unicodeletters}
\input{agda-generated}
\input{agdamacros}


%% Rights management information.  This information is sent to you
%% when you complete the rights form.  These commands have SAMPLE
%% values in them; it is your responsibility as an author to replace
%% the commands and values with those provided to you when you
%% complete the rights form.
% \setcopyright{acmlicensed}
% \copyrightyear{2018}
% \acmYear{2018}
% \acmDOI{XXXXXXX.XXXXXXX}
% %% These commands are for a PROCEEDINGS abstract or paper.
% \acmConference[Conference acronym 'XX]{Make sure to enter the correct
%   conference title from your rights confirmation email}{June 03--05,
%   2018}{Woodstock, NY}
% %%
% %%  Uncomment \acmBooktitle if the title of the proceedings is different
% %%  from ``Proceedings of ...''!
% %%
% %%\acmBooktitle{Woodstock '18: ACM Symposium on Neural Gaze Detection,
% %%  June 03--05, 2018, Woodstock, NY}
% \acmISBN{978-1-4503-XXXX-X/2018/06}


%%
%% Submission ID.
%% Use this when submitting an article to a sponsored event. You'll
%% receive a unique submission ID from the organizers
%% of the event, and this ID should be used as the parameter to this command.
%%\acmSubmissionID{123-A56-BU3}


\begin{document}

\title{What I Always Wanted to Know About Second Class Values}

%%
%% The "author" command and its associated commands are used to define
%% the authors and their affiliations.
%% Of note is the shared affiliation of the first two authors, and the
%% "authornote" and "authornotemark" commands
%% used to denote shared contribution to the research.
\author{Peter Thiemann}
\email{thiemann@acm.org}
\orcid{0000-0002-9000-1239}
\affiliation{%
  \institution{University of Freiburg}
  \city{Freiburg}
  \country{Germany}
}

\begin{abstract}
Second class values are allocated on the run-time stack and they may contain pointers
to other values on the stack. They were first discussed in connection with the
infamous funarg problem, but then forgotten as heap-allocated closures were
discovered.

Recent work has resurrected the interest in second class values as they allow us
to safely allocate some data structures (e.g., closures) on the run-time stack.
This approach has the advantage of avoiding the cost of garbage collection for
these structures as their deallocation has no extra cost when the stack is popped.
A system with qualified types ensures that second class values do not
escape across stack pops.

We take a second look at this work with the following questions in focus.

\begin{itemize}
\item What, exactly, is the meaning of a type qualifier?  
\item Can we implement this scheme with a type-based, selective CPS
  translation?
\item Can we extend the formal framework of previous work
  with first-class and second-class references?
\end{itemize}
\end{abstract}

%%
%% The code below is generated by the tool at http://dl.acm.org/ccs.cfm.
%% Please copy and paste the code instead of the example below.
%%
% \begin{CCSXML}
% <ccs2012>
%  <concept>
%   <concept_id>00000000.0000000.0000000</concept_id>
%   <concept_desc>Do Not Use This Code, Generate the Correct Terms for Your Paper</concept_desc>
%   <concept_significance>500</concept_significance>
%  </concept>
%  <concept>
%   <concept_id>00000000.00000000.00000000</concept_id>
%   <concept_desc>Do Not Use This Code, Generate the Correct Terms for Your Paper</concept_desc>
%   <concept_significance>300</concept_significance>
%  </concept>
%  <concept>
%   <concept_id>00000000.00000000.00000000</concept_id>
%   <concept_desc>Do Not Use This Code, Generate the Correct Terms for Your Paper</concept_desc>
%   <concept_significance>100</concept_significance>
%  </concept>
%  <concept>
%   <concept_id>00000000.00000000.00000000</concept_id>
%   <concept_desc>Do Not Use This Code, Generate the Correct Terms for Your Paper</concept_desc>
%   <concept_significance>100</concept_significance>
%  </concept>
% </ccs2012>
% \end{CCSXML}

% \ccsdesc[500]{Do Not Use This Code~Generate the Correct Terms for Your Paper}
% \ccsdesc[300]{Do Not Use This Code~Generate the Correct Terms for Your Paper}
% \ccsdesc{Do Not Use This Code~Generate the Correct Terms for Your Paper}
% \ccsdesc[100]{Do Not Use This Code~Generate the Correct Terms for Your Paper}

\keywords{Second class values, functional programming, qualified types}

%%
%% This command processes the author and affiliation and title
%% information and builds the first part of the formatted document.
\maketitle
\lstset{language=lisp}
\section{Introduction}

When the implementation of functional programming languages was still
an art, implementors were struggling to make all values ``first
class''. In particular, function values. In this context, first
class means that a function can be passed as an argument to another
function, returned as a result, or stored in a data structure. Thus,
it is a key feature to enable full-fledged higher-order programming.

Soon, implementors ran into the funarg problem \cite{moses70:_funct_lisp_funar}. This problem arises
when a function is passed as an argument or returned from a function
call. The issue is that the function in transit may refer to free
variables, and when the function leaves its defining scope, these free
variables become dangling references. 

Here is an example in Lisp.
\begin{lstlisting}
(defun make-adder (x)
  (lambda (y) (+ x y)))

(setq add5 (make-adder 5))
(add5 3) ; => 8
\end{lstlisting}
The call to \lstinline|(make-adder 5)| creates a stack frame that
contains the binding \texttt{x = 5}. If the \lstinline|lambda| were just
returned as an expression, it would contain a dangling reference to
\texttt{x} because the stack frame is popped after the call.

This example is an instance of the \emph{upward funarg problem}
(return a function). The
dual \emph{downward funarg problem} (pass a function as a parameter)
is usually not a problem 
because the values that function bodies refer to are still available
on the stack. Pascal \cite{jensen91:_pascal} is a language that implemented this design:
functions can be passed downwards, but not returned. 

The well-known solution to the problem is representing functions by
closures that contain an environment with copies of the values of all
free variables besides the function body (or the code pointer in
compiled code) \cite{landin66,DBLP:conf/acm/Reynolds72}.
Usually, a closure is a heap-allocated data structure because its
lifetime can exceed the defining scope---indeed, for addressing the
upward funarg problem, it is a requirement that the closure can escape
from its defining scope.

Unfortunately, excessive heap allocation puts stress on the garbage
collector whereas memory management for stack-allocated data comes
(almost) for free. This idea was pushed to its limits by the seminal work on
region-based memory management
\cite{DBLP:conf/popl/TofteT94,DBLP:journals/iandc/TofteT97}.

Recent work on second class values
\cite{DBLP:conf/oopsla/OsvaldEWAR16} has
added a new, low cost angle to this subject. In this work, the authors
propose a qualified type system that categorizes values as first-class
or second-class with the rough intutition that first-class values are
heap allocated. This work has subsequently been refined in the core
calculus $\LamWhatif$
\cite{DBLP:conf/ecoop/XhebrajB0R22}, where functions are
either represented by heap closures or by stack closures. Invoking a
heap closure pushes a new stack frame and pops it on return from the
closure. Invoking a stack closure merely extends the current stack
frame and does \emph{not} pop it on return.
This model enables writing code that can locally allocate data on the
stack as long as it does not escape from the most recently invoked
heap closure.

This idea extends to stack allocation of data structures
other than closures. Here is an example using arrays (in Python-style syntax):
\begin{lstlisting}[language=python]
def add(l: Array[int],
        r: Array[int]
       ) -> SArray[int]:
    return SArray[l[0]+r[0], l[1]+r[1]]
def norm (arr: SArray[int]) -> int:
    return arr[0]*arr[0] + arr[1]*arr[1]
def addnorm (l: Array[int],
             r: Array[int]) -> int:
    return norm (add(l, r))
\end{lstlisting}
Let's assume that the type \texttt{Array} is
allocated on the heap while \texttt{SArray} is stack-allocated.
Further,  assume that \texttt{addnorm} is a heap closure while \texttt{add}
and \texttt{norm} are stack closures.
In this configuration, \texttt{add} can safely allocate the
\texttt{SArray} on the run-time stack.

Here is what happens when invoking \texttt{addnorm} on two lists, step by step.
\begin{itemize}
\item Create a new stack frame with arguments \lstinline|l| and
  \lstinline|r|.
\item Extend the stack frame to call \texttt{add}.
\item The function \texttt{add} allocates the
  \texttt{SArray} on the current stack frame and returns
  \emph{without popping the frame}.
\item Extend the stack frame to call \texttt{norm}; the argument
  points to the \texttt{SArray} in the stack frame.
\item Return the result of \texttt{norm} \emph{without popping the
    stack}.
\item Finally, return the result and pop the combined stack frame for
  \texttt{addnorm}, \texttt{add}, and \texttt{norm}.
\end{itemize}

In the rest of the paper, we introduce a call-by-value lambda calculus $\LamOurs$
with second class functions and second class references, which can
express a computation just like the one for \texttt{addnorm}. Our
calculus $\LamOurs$ is heavily inspired by $\LamWhatif$, but it
implements some subtle changes and one major extension.

\begin{itemize}
\item Like $\LamWhatif$, $\LamOurs$ comes with a qualified type system
  that classifies values into first and second class.
\item $\LamOurs$ implements a more realistic encoding of stack frames
  than $\LamWhatif$ because it pushes arguments of stack closures on
  the stack and accesses them by pointers into the stack. In contrast, the formal model of
  $\LamWhatif$ apparently copies relevant parts of the stack.
\item $\LamOurs$ extends $\LamWhatif$ by mutable references that can
  be safely allocated on the stack or on the heap. This extension
  requires a subtle change in the type system compared to $\LamWhatif$
  (see Section~\ref{sec:types} for discussion). 
\end{itemize}
The definition of $\LamOurs$ and its type soundness proof are fully
mechanized in Agda
\cite{DBLP:conf/afp/Norell08,team25:_agda_homep}. The source code is
separately available in a GitHub
repository\footnote{\url{https://github.com/peterthiemann/what-if.git}}. 
The main body of this paper contains comments excerpts of this
mechanized development. We expect readers to be reasonably fluent with
Agda's syntax. 

In the conclusions, we return to the questions raised in the abstract.
\begin{itemize}
\item What, exactly, is the meaning of a type qualifier?  
\item Can we implement this scheme with a type-based, selective CPS
  translation?
\item Can we extend the formal framework of previous work
  with first-class and second-class references?
\end{itemize}

\section{Syntax}
\label{sec:syntax}

\subsection{Qualifiers}
\label{sec:qualifiers}


We start by defining the type qualifiers  and their ordering.
\Qual

Type qualifiers form a complete lattice with lattice order $\le$. We
prove that $\le$ is a partial order and that evidence for the order is unique.

Type qualifiers are used throughout. The first intuition is that
{\AOne} indicates heap-related things and {\ATwo} indicates
stack-related things.  Qualifiers show up in the syntax of
types and expressions and also as indices for the evaluation
judgment and we make the definition more precise in each case.

\subsection{Types}
\label{sec:types}



Qualified types are defined by mutual recursion between $\AType$ and
$\AQType$.
\QType
The $\AQType$ only manages the qualifier and defines the type indexed
by the qualifier. The $\AType$ comprises the unit type, base type,
function and reference type. The latter two contain well-formedness
constraints to ensure that types are meaningful.

Specifically, the constraint for $\ACRef$ enforces that a heap
reference cannot contain a stack value. Otherwise, the stack value
would be able to escape its defining scope.
The constraint for $\ACFun$ ensures that a heap-allocated function
only has heap values as arguments and as results.

The earlier calculus $\LamWhatif$ does not impose either of these
constraints: references are not supported by $\LamWhatif$ and we are
forced to restrict function types like this because we added
references.

Let's consider an example to see the need for this
restriction. Generally, if we pass a stack value to a heap closure,
then we need to ensure that the callers' stack does not get
corrupted. In $\LamWhatif$, there is no problem, but references may
corrupt the stack.

Concretely, consider a stack reference $r : \ACRef~\ATwo~(\ACRef~\ATwo~\AInt)$ which contains
another stack reference to a number and suppose we can pass that value
to a heap-allocated closure. That is, we create a new
stack frame, which gets popped on return from the heap closure.
On the local stack, we create a new reference as in $x =
\ACref~\ATwo~(42)$ of type $x : \ACRef~\ATwo~\AInt$.
The typing allows us to update $r$ with this fresh reference as in $r
:= x$. But now the callers' stack contains a reference to the current stack
frame, which becomes invalid after returning from the heap closure (which
pops the top-most stack frame).

We chose a simple approach (implemented by wellformedness constraints
in types) to avoid this situation by disallowing 
stack references (more generally: stack values) as arguments to heap
closures. The recent literature contains several reports that consider
less constrained (but vastly more complex) systems (e.g.,
\cite{DBLP:journals/pacmpl/BaoWBJHR21,DBLP:journals/pacmpl/LorenzenWDEL24}),
but we leave further exploration of design 
alternatives to future work.

\subsection{Expressions}
\label{sec:expressions}

Variables are slightly special as they are indexed with a qualifier,
which is intended to provide an upper bound of the class of the value
bound to the variable. Identifiers \AFun{Ident} are just strings.
\Variables

The syntax of expressions is standard. Two constructors take
qualifiers as arguments. The $\ACref$ constructor to direct allocation
to heap or stack and the $\AClam$ constructor to mark argument and
return values.
\Expr


\section{Run-Time Objects}
\label{sec:run-time-objects}

\Values

A value is either unit, constant, closure, or reference. The qualifier
$q$ of a reference indicates whether it is a heap or a stack
reference; the $\ell$ is the address on the heap or the current stack
frame. A closure consists of the closure's qualifier $q$, the
environment $\mathcal{E}$ with bindings for the free variables, the
stack $\mathcal{S}$ when the closure was created, the closure variable
$x$, the closure's body expression $e$, and the final qualifier to
indicate the class of the return value.

An environment of type $\AEnv$ is either empty, or it is extended with
a heap binding containing the value, or it is extended with a stack
value, in which case the environment contains the address of the value
in the (current) stack frame.

A stack $\mathcal{S}$ consists of two lists of values. The list
\texttt{vars} contains stack values referenced from the environment
and the list \texttt{refs} contains ``memory cells'' to be used for
stack references.\footnote{Strictly speaking, we could collapse the
  two lists into one and represent a stack frame as a linear array of
  memory cells, but this structure is more easy to deal with in the
  soundness proof.}

The stack extension relation is defined by pairing the prefix relation
on variables and $\le$ on the lengths of the references.
\StackExtension

Finally, a heap $\mathcal{H}$ is just a list of values, i.e., the
memory cells for heap references. 

\section{Typing}
\label{sec:typing}


\subsection{Subtyping}
\label{sec:subtyping}
\begin{figure}[tp]
  \SubtypingRelation  
  \caption{Subtyping}
  \label{fig:subtyping}
\end{figure}

Figure~\ref{fig:subtyping} contains the subtyping rules. Rules are
structured in two mutually recursive layers, just like types. The
relation on $\AQType$ enables subsumption from heap values to stack
values: any value that can be put on the heap can safely be put
on the stack. The relation on $\AType$ just extends qualifier
subtyping in the standard way by enforcing contravariant and covariant
behavior for arguments and results of a function as well as invariant
behavior for values in a reference.


\subsection{Typing rules}
\label{sec:typing-rules}
\begin{figure}[tp]
  \TypingRules  
  \caption{Typing}
  \label{fig:typing}
\end{figure}
Figure~\ref{fig:typing} contains the typing rules. Most of them are
standard and unsurprising: type structure and qualifiers have to
match. Unit values and constants are never put on the stack, so their
qualifier does not matter. Rule {\ACTAbs} defines the typing of an
abstraction. The qualifier $q$ of the {\AClam} constructor determines
the class of the closure. The body of the lambda is typed in a
restricted typing context $\Gamma'$ which contains only the
bindings with class $\le q$ from the original context. This
restriction is enforced by the {\AqBounded} relation. The remaining
parts of the rule enforce the well-formedness of the type
qualification.

It is interesting to observe that all elimination positions in the
typing rules ask for second class values. This observation yields a
different interpretation of the qualifiers in types: A second class
value is never put on the heap. It is either directly consumed or
stored on the stack. In contrast, a first class value can be put on
the heap.

\subsection{Run-time typing}
\label{sec:run-time-typing}
\begin{figure}[tp]
  \ValueTyping
  \caption{Run-time typing}
  \label{fig:run-time-typing}
\end{figure}

Figure~\ref{fig:run-time-typing} contains the definitions for run-time
typing. The first relation formalizes value typing $\langle \Sigma_h,
\Sigma_s \rangle\vdash{[ v \typecolon S]}$ --- in heap type $\Sigma_h$
and stack type $\Sigma_s$, value $v$ has qualified type $S$. The
second relation formalizes agreement of context, run-time environment,
and stack: $\langle \Sigma_h , \Sigma_s,
\Gamma\rangle\models\mathcal{E}/\mathcal{S}$ --- in heap type
$\Sigma_h$, stack type $\Sigma_s$, and variable context $\Gamma$, we
have agreement with the run-time environment $\mathcal{E}$ and stack
$\mathcal{S}$.

Agreement consists of two components, $\models$-heap and
$\models$-stack.
$\models$-heap says that any variable binding of a heap variable to a
heap type in $\Gamma$ gives access to the value of this variable in
the run-time environment and the value has the type predicted by the
context.
$\models$-stack says that any binding of a stack variable to a type in
$\Gamma$ gives access to the stack address of this variable in the
run-time environment; moreover, looking up this address in the stack
succeeds and yields a value of the type predicted by the context.

Value typing for unit and constant is simple because they do not
depend on stack or heap.

Value typing for a closure in rule {\ACTVClos} contains a run-time
environment, but this run-time environment agrees with any stack that
is an extension of the creation stack $\mathcal{S}$ of the
closure. The qualifier $q$ determines the class of the closure; the
\AFun{new-frame?} operator returns the empty stack for a heap closure
and otherwise the identity.
The context has to be $q$ bounded.
The body $e$ is typed with argument $S_1$ and result $S_2$.
The final subtyping judgment enables us retype the value with any
subtype.

Value typing for a reference in rule {\ACTVRef} dispatches on class
$q$ between the type environment $\Sigma_h$ for the heap and
$\Sigma_s$ for the stack. It affirms that the pointer $\ell$ is valid
(less than the length of the respective environment) and that looking
up the environment at $\ell$ yields the expected type $T$.
The final subtyping judgment has the same function as for closures.

\subsection{Typing stacks and heaps }
\label{sec:typing-stacks-heaps}

Heap typing and stack typing are both straightforward. The typing
environment is a list of (heap) types which is pointwise related to a
list of values by the run-time value relation. Heap values do not
depend on stack values, so the stack type is not needed for typing a heap.

\HeapTyping
\StackTyping


\section{Evaluation}
\label{sec:evaluation}

We formalize evaluation in terms of an eight-place big-step evaluation
relation
$\mathcal{E}, \mathcal{H}, \mathcal{S} \vdash e \Downarrow{[ q ]} v
\dashv \mathcal{H}', \mathcal{S}'$ ---
in run-time environment $\mathcal{E}$ with heap $\mathcal{H}$ and
stack $\mathcal{S}$, the expression $e$ evaluates with target class
$q$ to value $v$, output heap $\mathcal{H}'$ and output stack
$\mathcal{S}'$.

There is exactly one evaluation rule for each
syntactic construct. This setup is different to $\LamWhatif$, where
all evaluation rules come in pairs, indexed by their class.

\RuleEUnit
Evaluation of a unit preserves heap and stack.

\RuleEVar
Variables are accessed through the environment. Heap variables yield
values, stack variables yield addresses, and the \AFun{decode}
function dereferences address on the stack, if needed.

\RuleEAbs
This rule distinguishes between heap allocated and stack allocated
closures guided by the annotation $q_1$. The former are created with the empty stack while the latter
pick up the stack where they were created. The \AFun{q-bounded-Env}
relation removes binding with class greater than $q$ from the run-time
environment.

\RuleEApp
This rule deals with four cases at once. It distinguishes on $q$
between heap and stack closures and it distinguishes on $q_1$ between
heap and stack arguments. The former is handled by either creating a
new stack frame or reusing the existing one (function
\AFun{new-frame?} and function \AFun{restore-frame?} to pop). The
latter is handled by the operators $\oplus$ which either adds a value
or its address to the run-time environment and $\oplus_s$ which
conditionally pushes a value on the stack.

\RuleERef
To create a reference of class $q_1$, we evaluate its body at class
$q_1$. Then we either allocate it on the heap or on the stack and
leave the other component unchanged.

\RuleEDeref
We evaluate the argument of deref at class $\ATwo$, then we either
read the value from the heap or from the stack depending on the class
of the reference.

\RuleESetref
We evaluate the first argument of setref at class $\ATwo$ and the
second at the class $q_1$ expected by the reference. The we either
write to the heap or to the stack.

\RuleESeq
We evaluate the first subexpression of the sequence at class $\ATwo$ and
then the second subexpression at the class $q$ expected by the context.

\section{Soundness}
\label{sec:soundness}
\begin{figure}[tp]
  \Wellformed
  \caption{Wellformedness}
  \label{fig:wellformedness}
\end{figure}
In preparation for the soundness proof, we need an auxiliary notion of
wellformedness. This notion essentially tells us that whenever
evaluation yields a stack closure, then the current stack is an
extension of the creation stack of the closure. Thus, it is safe to
continue using the closure.

Figure~\ref{fig:wellformedness} contains the relevant definitions. In
the definition of the {\AWellformed} type, we first check if the value
is a closure to obtain its run-time environment $\mathcal{E}$ and its
creation-time stack $\mathcal{S}^c$. If the value is a heap value,
then the creation-time stack is empty and $\mathcal{E}$ is a pure heap
environment. Furthermore, the current stack $\mathcal{S}$ is an
extension of the creation-time stack and the run-time environment is
wellformed in both stacks.

A wellformed environment contains only wellformed values and all heap
bindings are heap values.

Wellformedness extends in the obvious way to heaps and stacks.

\begin{figure}[tp]
  \SoundnessResult  
  \caption{Results}
  \label{fig:soundness-result}
\end{figure}
The result of soundness is a record shown in
Figure~\ref{fig:soundness-result}.
It is parameterized over the input heap type, input stack type, the
return value $v$, its type $S$, the output heap $\mathcal{H}'$, and
the input and output stack $\mathcal{S}$ and $\mathcal{S}'$ of an
evaluation. It contains all relevant information to prove soundness by
induction on the evaluation relation. 

Here is the statement of the soundness theorem as proved.
\EvalSoundness
It states that all stack and heap accesses during evaluation of a
typed term are safe.

\section{Conclusions}
\label{sec:conclusions}

To conclude, let's get back to the questions raised in the beginning.

\subsection*{What, exactly, is the meaning of a type qualifier?}

The meaning depends on the respective purpose. The meaning for
\emph{specifying allocation} is $\AOne \to$ heap and $\ATwo \to$ stack. Another purpose
is to indicate a \emph{context of use} for a value. In this case $\AOne$
means ``this value may be put on the heap'' and $\ATwo$ means ``this
value will never be put on the heap'' (directly or indirectly).
\begin{itemize}
\item In types, the qualifier indicates the context of use.
\item In expressions, the type qualifier indicates the allocation site
  of references and closures. In a lambda expression $\AClam~q~ x~ e~
  q_1$, the second $q_1$ indicates the context of use for the body $e$
  of the lambda.
\item In values, the qualifier indicates the location where the value
  was allocated. In a closure, the second qualifier plays the same
  role as $q_1$ for lambda expressions.
\item In the evaluation judgment, the qualifier index $q$ denotes the
  context of use. This meaning can be derived from the way the
  constructs evaluate their elimination position in context $\ATwo$:
  these values will never be put on the heap, because they are
  destructed at this point of evaluation.
\end{itemize}

\subsection*{Can we implement this scheme with a type-based, selective CPS translation?}

Let's first clarify what we mean with this question. The classic
approach of compiling with continuations
\cite{DBLP:conf/acm/Steele77} goes (very roughly) like this:
Apply a wholesale CPS translation to the program, distinguish (local)
calls to continuations from serious function calls, implement the
former by jumps (reusing the stack frame) and the latter by full blown 
function calls that allocate fresh stack frames.

This approach can be implemented in an entirely heap-based manner
\cite{DBLP:books/cu/Appel1992}, but most compiler writers try to use
the stack to represent continuations for serious function calls. 

A little thought reveals that invocations of second class functions
live in between the jump and the full-blown function call. Hence, they
could be implemented by a jump combined with a stack-allocated
continuation. A 
possible tool for the first step in such an implementation of
$\LamOurs$ could be a selective CPS translation that \emph{does not}
transform calls to heap-allocated functions. This possibility
was hinted at in prior work \cite{DBLP:conf/ecoop/XhebrajB0R22},
\emph{but} for a version of $\LamWhatif$ \emph{without subtyping}.

In $\LamOurs$ with qualifier-driven subtyping, the type does not
convey enough information to determine the class of a closure. Indeed,
the typing rule for function application always expects a second-class
function of type $\ACFun~S_1~S_2~wf_1~wf_2~\hat{}~\ATwo$, but at run
time it could be a heap closure or a stack closure, as one can see
from the evaluation rule \ACon{EApp} for function application.

One strategy to address this situation would be to move from
set-theoretic subtyping to coercive subtyping
\cite{DBLP:conf/tacs/Reynolds91,DBLP:journals/logcom/Luo99}, where the
coercion at function types would correspond to eta expansion. The resulting
calculus would be amenable to a selective CPS translation, but one
would also have to discuss coherence of subsumption. We leave this
exploration to future work.

\subsection*{Can we extend the formal framework of previous work
  with first-class and second-class references?}

As we demonstrate in this paper, it is possible to extend the prior
work \cite{DBLP:conf/ecoop/XhebrajB0R22} with first and second class
references. In Section~\ref{sec:types} we explain the differences
between $\LamWhatif$ and $\LamOurs$ in terms of wellformedness of
qualified types.

While we believe there is a less restrictive version of $\LamWhatif$
that eliminates wellformedness, it requires a careful design. We
already discussed the issue with stack references of stack references,
but, of course, the same problem arises with (nested) stack closures
that contain stack references. Thus, a revised calculus would have a
significantly more complicated type system that keeps track of life
times and aliasing, probably along the lines of reachability types
\cite{DBLP:journals/pacmpl/BaoWBJHR21}. Again, we leave this
exploration to future work.

\begin{acks}
  Thanks to Julius Fischer for the many discussions on the subject. He
  implemented a prototype interpreter for $\LamOurs$ as part of his
  bachelor thesis.\footnote{\url{https://github.com/Proglang-Uni-Freiburg/LambdaCPS.git}}
\end{acks}

%%
%% The next two lines define the bibliography style to be used, and
%% the bibliography file.
\bibliographystyle{ACM-Reference-Format}
\bibliography{second-class}



\end{document}
\endinput
%%
%% End of file `second-class.tex'.
